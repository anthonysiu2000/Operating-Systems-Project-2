Names/netid: Jonathan Konopka (jk1549), Anthony Siu (ays53)


Logic:
    Thread Functions:
        myThreadCreate:
            In order to implement the create mythread API, We will follow the directions set
        in the instructions. We will first create a new thread control block, which will 
        contain the thread id, quantum time elapsed(qte), thread context, thread output, and thread 
        status. We will dynamically allocate memory for each control block.
            After setting thread id to the thread id given in the input, initializing status 
        to scheduled and setting qte to 0, we will create the thread context using the getcontext 
        and makecontext functions.
            After creating and allocating the thread control block, we will add the tcb onto
        the scheduler Linked List of tcbs. The scheduler will decide which thread to run and for how
        long. We do this by inserting a tcb Node into the scheduler Linked List. 

        myThreadYield:

        myThreadExit:
            We pause the timer.
            We set the tcb's output equal to the result of the thread, if the input is not NULL.
            We will then context switch back to the scheduler.

        myThreadJoin: 
            We deallocate the tcb be by simply calling the free() function on the tcb. We do not need to 
        remove the tcb from the linked list, as it has already been removed.

    Scheduler:
        Deciding on which thread: 
            Following the rules set by STCF, our goal is to context switch into the thread with 
        the lowest quantum time elapsed. We will choose a data structure with easy access to
        this variable while also maintaining the ability to insert tcbs at any point in the 
        structure. Because queues and stacks can only insert at one end of the list, we have
        chosen the linked list data structure, where tcbs at the front will have lower quantum
        time elapsed, while tcbs at the rear will have larger quantum time elapsed. We will remove
        the tcb at the front of the list while at the same time context switching to that tcb's
        context.

        Timer Signal:
            Whenever timer ends, and the thread has not exited, we have to increase qte for
        the current tcb by one, set status to scheduled, and context switch back to the 
        scheduler. In addition, because we had previously removed the thread from the arraylist,
        we will insert it back in, accounting for the change in qte.        

        SetTimerQuantum:
            We will preset the Timer Quantum as 5000 microseconds as a global variable.

        SetTimer:
            One of the arguments in settimer()/gettimer() involves the variable "which", which
        can have the value ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF. Each of these values
        define when the timer decrements: in real time, when the process is executing, and
        when the process and system are executing. Because we want the time taken by the 
        thread for one quantum time, we will use the ITIMER_VIRTUAL value to decrement time 
        only when inside a thread.

        SetTimer code location:
            We will call settimer in the scheduler function and then immediately context switch to
        the thread with the least qte.




Benchmark:


Challenging part:



Improvement: 